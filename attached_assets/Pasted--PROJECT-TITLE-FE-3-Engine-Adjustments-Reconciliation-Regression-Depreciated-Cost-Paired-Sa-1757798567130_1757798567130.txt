
PROJECT TITLE
FE: 3-Engine Adjustments + Reconciliation — Regression • Depreciated Cost • Paired Sales with slider blending, ranges, provenance, and exportable audit trail. Mock API only; no changes to secured Photo endpoints.

SCOPE RULES
	•	Do NOT touch Photo API.
	•	Add mock Market/Comps adjustments routes under app/api/orders/[id]/adjustments/* persisting to /data/orders/<id>/adjustments/*.json.
	•	UI integrates into Comps tab (new Adjustments drawer/panel) and Reconciliation tab.

⸻

Data Model (types)

types/adjustments.ts

export type AttrKey =
  | 'gla' | 'bed' | 'bath' | 'garage' | 'lotSize' | 'age' | 'quality' | 'condition' | 'view' | 'pool';

export interface EngineWeight { engine: 'regression'|'cost'|'paired'; weight: number } // 0..1 normalized
export interface AttrAdjustment {
  key: AttrKey;
  // per-engine suggestion (currency per unit, e.g., $/SF for GLA, $ per bath, or % for condition if needed)
  regression?: { value: number; lo: number; hi: number; n: number; r2?: number };
  cost?:       { value: number; lo: number; hi: number; basisNote?: string };
  paired?:     { value: number; lo: number; hi: number; nPairs: number };
  // chosen value after blending + user nudges
  chosen: { value: number; source: 'blend'|'manual'; note?: string };
  unit: '$/sf' | '$/unit' | '$' | '%';
  direction: 'additive' | 'multiplicative'; // $ or % model
  provenance: Array<{engine: 'regression'|'cost'|'paired'; ref: string}>; // IDs for audit
}

export interface EngineSettings {
  weights: EngineWeight[]; // normalized; default regression 0.5, cost 0.25, paired 0.25
  decimalPlaces?: number;  // display precision
  capPctPerAttr?: number;  // optional guardrail for % attrs
}

export interface AdjustmentRunInput {
  orderId: string;
  compIds: string[];           // which comps to evaluate (candidate + primary)
  subject: { gla: number; bed: number; bath: number; garage?: number; lotSize?: number; age?: number; quality?: number; condition?: number; pool?: boolean; view?: number };
  marketBasis: 'salePrice'|'ppsf';
}

export interface AdjustmentRunResult {
  runId: string;
  computedAt: string;
  attrs: AttrAdjustment[];
  settings: EngineSettings;
}

export interface CompAdjustmentLine {
  compId: string;
  lines: Array<{ key: AttrKey; delta: number; rationale: string }>; // per-attribute $ delta applied
  subtotal: number;            // sum of lines (time adj NOT included here; you already show it separately)
  indicatedValue: number;      // salePrice + timeAdj + subtotal (or ppsf basis → convert)
}

export interface ReconciliationState {
  orderId: string;
  primaryCompIds: string[]; // #1..#3
  compLocks: string[];
  engineSettings: EngineSettings;
  overrideNotes?: string;
  selectedModel: 'salePrice'|'ppsf';
}

export interface AdjustmentsBundle {
  run: AdjustmentRunResult;
  compLines: CompAdjustmentLine[];
  reconciliation: ReconciliationState;
}


⸻

Mock API (Next.js route handlers)

Create under app/api/orders/[id]/adjustments/:
	1.	POST /compute
Input: AdjustmentRunInput
Output: AdjustmentRunResult
Logic (mock but realistic):
	•	Regression: fit simple multiple regression (OLS) on available comps:
	•	If marketBasis==='ppsf', regress $/SF on deltas (GLA as log or ratio, quality/condition as ordinals, etc.).
	•	Else regress salePrice on attributes.
	•	Return per-attribute marginal effects as $/unit (or % where appropriate). Provide lo/hi via ±1 SE (mock OK).
	•	Cost: lookup table (seed JSON) mapping attributes to typical replacement cost deltas (e.g., $/SF shell; $/bath; $/garage bay) and derive depreciated value using a simple age/life curve (seed).
	•	Paired: detect near-pairs within the comps (distance < X mi, close date within Y mo, similar GLA ±Z%, same quality/condition) and compute observed deltas per attribute; return median with range and nPairs.
	•	Blend: compute default chosen.value per attribute via normalized engine weights (no user overrides yet).
Persist AdjustmentRunResult to /data/orders/<id>/adjustments/run.json.
	2.	GET /run → last AdjustmentRunResult.
	3.	PUT /settings → save EngineSettings (weights, caps, precision). Persist to /data/orders/<id>/adjustments/settings.json.
	4.	POST /apply
	•	Build per-comp lines using run.attrs[].chosen.value × (comp − subject) deltas.
	•	Output compLines with subtotal and indicatedValue (include your time adj factor read from existing MCR endpoint).
	•	Persist an AdjustmentsBundle to /data/orders/<id>/adjustments/bundle.json.
	5.	GET /bundle → return AdjustmentsBundle.

Seed helper JSON under /data/adjustments/:
	•	cost-baseline.json (e.g., base $/SF by quality tier; $/bath; $/garage bay; pool; view premiums)
	•	depreciation.json (e.g., straight-line or age/life curve)

⸻

UI – Comps Tab: Adjustments Panel

Components
	•	components/adjustments/EngineWeights.tsx — three sliders (Regression/Cost/Paired) with normalized total = 1. “Reset to Shop Defaults”.
	•	components/adjustments/AttrTable.tsx — rows per attribute:
	•	Columns: Attr, Regression value (±range, n/r²), Cost value, Paired value (nPairs), Blend slider override + chosen value, Unit, Direction, “Provenance” link.
	•	Inline notes + “lock” toggle per attr (keeps chosen value fixed when re-compute runs).
	•	components/adjustments/ProvenanceModal.tsx — shows the sources (pair IDs, cost baseline row, regression summary).
	•	components/adjustments/ApplyBar.tsx — “Compute Suggestions” → POST /compute; “Apply to Comps” → POST /apply; success toast.

Behavior
	•	Open panel from Comps tab toolbar (“Adjustments”).
	•	First load: fetch /run + /settings; if none, show “Compute Suggestions”.
	•	Changing engine weights → live blend preview (no write until Save/Apply).
	•	User can override chosen.value per attribute (with note), lock/unlock.
	•	“Compute Suggestions” re-runs engines but does not overwrite locked attrs.

⸻

UI – Comps Cards: Lines & Totals

Enhance existing comp cards to show after time-adj:
	•	New collapsible “Attribute Adjustments” section:
	•	Line items per attr (e.g., “GLA +$12,300 @ $60/SF × 205 SF”).
	•	Subtotal (attribute only).
	•	Indicated Value = Original Sale Price + Time Adj + Subtotal.
	•	Hover tooltips show how each line was derived and which engine(s) contributed (from provenance).
	•	Respect locked primaries (already done) — no auto swap.

⸻

Reconciliation Tab Enhancements
	•	Primary trio weights slider: allow user to weight #1/#2/#3 (e.g., 60/30/10) to display a Weighted Indicated Value.
	•	Narrative helper that composes: time adjustment basis & rate, engine mix, key lines that drove deltas, and final reconciliation rationale.
	•	Button “Copy narrative to clipboard”.

⸻

Acceptance Criteria (demo)
	•	Clicking Adjustments opens panel; first run computes Regression/Cost/Paired suggestions with ranges and sample sizes.
	•	Three engine sliders blend to 100%; changing them updates chosen values live (without overwriting locked attrs).
	•	Provenance modal shows where each suggestion came from (pairs list, cost baseline row, regression summary).
	•	Apply to Comps populates per-comp line items, subtotal, and Indicated Value, visible on both candidate and primary comps.
	•	Time adjustment (from MCR) is included before attribute lines in the indicated value math.
	•	Reconciliation tab shows weighted indicated value from the three primaries and provides a copyable narrative.
	•	State persists to /data/orders/<id>/adjustments/*.json.
	•	No Photo API changes.

⸻

Manual Test (quick)
	1.	Compute Suggestions → verify values for GLA, bath, condition; see ranges & counts.
	2.	Drag engine weights to (Reg 0.7 / Cost 0.2 / Paired 0.1) → chosen values update.
	3.	Lock GLA adjustment; recompute → GLA holds, others refresh.
	4.	Apply to Comps → open a primary comp: see time adj + line items + Indicated Value; totals make sense.
	5.	Open Provenance for “bath” → see pair examples and cost baseline.
	6.	On Reconciliation, set comp weights 50/30/20 → weighted value updates; copy narrative.
	7.	Refresh page → everything persists.

⸻

Nice-to-Have (if time)
	•	Fractional months option in time adj math (already scaffolded).
	•	Download Adjustments Audit (JSON/CSV) of the run, including engine inputs and outputs.
	•	Per-attr caps (e.g., max ±15% total).

⸻

Deliver exactly this slice so appraisers get transparent, defensible adjustments with a clean path to final reconciliation.

If you’d rather ship in smaller chunks, say “Do Regression first” and I’ll provide a mini-prompt just for the regression engine + UI.